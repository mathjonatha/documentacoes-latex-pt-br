% ======================================================================
% scrlayer-en.tex
% Copyright (c) Markus Kohm, 2013-2023
%
% This file is part of the LaTeX2e KOMA-Script bundle.
%
% This work may be distributed and/or modified under the conditions of
% the LaTeX Project Public License, version 1.3c of the license.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
% and version 1.3c or later is part of all distributions of LaTeX 
% version 2005/12/01 or later and of this work.
%
% This work has the LPPL maintenance status "author-maintained".
%
% The Current Maintainer and author of this work is Markus Kohm.
%
% This work consists of all files listed in MANIFEST.md.
% ======================================================================
%
% Chapter about scrlayer of the KOMA-Script guide
% Maintained by Markus Kohm
%
% ============================================================================

\KOMAProvidesFile{scrlayer-en.tex}
                 [$Date: 2023-04-25 09:00:44 +0200 (Di, 25. Apr 2023) $
                  KOMA-Script guide (chapter:scrlayer)]

\translator{Tradução para Português Brasileiro}

\chapter[{Definindo Camadas e Estilos de Página com \Package{scrlayer}}]
  {Definindo\ChangedAt{v3.12}{\Package{scrlayer}} Camadas e Estilos de Página com
	\Package{scrlayer}}
\labelbase{scrlayer}

\BeginIndexGroup
\BeginIndex{Package}{scrlayer}%
\BeginIndex{}{layer}%
A maioria dos usuários de software gráfico já está familiarizada com o modelo de camadas
para uma página. Tal modelo é bastante estranho ao próprio \LaTeX{}, mas alguns pacotes,
como \Package{eso-pic} ou \Package{textpos}, fornecem uma espécie de
camada de fundo ou primeiro plano. \Package{scrlayer} é outro pacote que
fornece tais camadas de fundo e primeiro plano, mas ao contrário dos pacotes
mencionados acima, essas camadas fazem parte do estilo de página. Como resultado, você pode
mudar entre diferentes camadas simplesmente alternando o estilo de página.

Para fazer isso, o pacote também suporta uma interface de baixo nível para definir estilos de página
baseados em uma pilha ou lista de camadas, para adicionar camadas a tal
pilha de camadas, seja no topo ou na base, ou antes ou após uma camada específica,
e para remover camadas individuais e duplicatas de uma pilha. Em resumo,
a interface de estilo de página de \Package{scrlayer} fornece comandos para
definir estilos de página baseados em uma pilha de camadas e para gerenciar essas pilhas.

No entanto, o uso direto de camadas é recomendado apenas
para usuários avançados. Interfaces para usuários iniciantes e médios são fornecidas por pacotes adicionais
que por sua vez carregam \Package{scrlayer}. Consulte
\autoref{cha:scrlayer-scrpage} em \autoref{part:forAuthors} deste
\iffree{manual}{livro}.


\LoadCommonFile{options} % \section{Early or Late Selection of Options}

\section{Informações Genéricas}
\seclabel{generic.information}

O pacote precisa de algumas informações genéricas sobre a classe sendo usada. Autores de classe
podem ajudar \Package{scrlayer} fornecendo as informações apropriadas.
Caso contrário, o pacote tentará determinar essas informações por si mesmo. Isto
funciona, por exemplo, para as classes padrão e \KOMAScript{}. Pode
funcionar com outras classes, ou pode falhar total ou parcialmente.

Esta seção descreve algumas das informações que autores de classe podem fornecer.
Normalmente, os usuários não precisam se preocupar com isso.

\begin{Declaration}
  \Macro{if@chapter}\ \PName{código então}\ \textMacro{else}\ %
  \PName{código senão}\ \textMacro{fi}%
\end{Declaration}
Se \Macro{if@chapter} é definido e corresponde a
\Macro{iftrue}\IndexCmd{iftrue}, \Package{scrlayer} leva em conta o nível de capítulo
ao processar, por exemplo, a opção
\DescRef{\LabelBase.option.automark}. Se for definido mas não for
\Macro{iftrue}, \Package{scrlayer} trata apenas as
unidades de seção \DescRef{maincls.cmd.part}, \DescRef{maincls.cmd.section},
\DescRef{maincls.cmd.subsection}, \Macro{sub\dots subsection},
\DescRef{maincls.cmd.paragraph}, \DescRef{maincls.cmd.subparagraph},
\Macro{sub\dots subparagraph}. Se a macro não for definida,
\Package{scrlayer} procura por \DescRef{maincls.cmd.chapter}. Se
\DescRef{maincls.cmd.chapter} é definido e não corresponde a
\Macro{relax}, \Package{scrlayer} define \Macro{if@chapter} como
\Macro{iftrue}. Caso contrário, \Macro{if@chapter} torna-se
\Macro{iffalse}\IndexCmd{iffalse}.%
\EndIndexGroup


\begin{Declaration}
  \Macro{if@mainmatter}\ \PName{código então}\ %
  \textMacro{else}\ \PName{código senão}\ \textMacro{fi}%
\end{Declaration}
Classes como \Class{book} ou \Class{scrbook} fornecem
\DescRef{maincls.cmd.frontmatter}\IndexCmd{frontmatter},
\DescRef{maincls.cmd.mainmatter}\IndexCmd{mainmatter}, e
\DescRef{maincls.cmd.backmatter}\IndexCmd{backmatter} para alternar entre as
partes frontal, principal e final de um livro. Normalmente, essas classes também usam
\Macro{if@mainmatter} internamente para decidir se o texto atual é parte
do corpo principal do documento ou não. Classes como \Class{report} e
\Class{article} não possuem \DescRef{maincls.cmd.frontmatter},
\DescRef{maincls.cmd.mainmatter}, ou \DescRef{maincls.cmd.backmatter} e
portanto também carecem de \Macro{if@mainmatter}.

É mais fácil para \Package{scrlayer} evitar constantemente testar a
existência desses comandos para decidir se deve trabalhar na parte principal ou
não, e em vez disso usar \Macro{if@mainmatter}\IndexCmd{iftrue} com classes
como \Class{report} e \Class{article}. Assim, se \Macro{if@mainmatter} não for
definido, \Package{scrlayer} o define como um sinônimo para \Macro{iftrue}.

Algumas classes, no entanto, definem \DescRef{maincls.cmd.frontmatter},
\DescRef{maincls.cmd.mainmatter}, ou \DescRef{maincls.cmd.backmatter} mas não
\Macro{if@mainmatter}. Neste caso, \Package{scrlayer} também define
\Macro{if@mainmatter} como \Macro{iftrue} e estende a definição de
\DescRef{maincls.cmd.frontmatter}, \DescRef{maincls.cmd.mainmatter}, e
\DescRef{maincls.cmd.backmatter} para definir \Macro{if@mainmatter} corretamente.
No entanto, se houver outros comandos comparáveis para alternar entre
diferentes partes do documento, \Package{scrlayer} não os reconhecerá, não
testará por eles e, portanto, não poderá estendê-los adequadamente. Neste caso,
\Package{scrlayer} precisa da ajuda do autor da classe para definir \Macro{if@mainmatter}
corretamente.%
\EndIndexGroup


\begin{Declaration}
  \Macro{DeclareSectionNumberDepth}\Parameter{nome do nível}%
                                   \Parameter{profundidade do nível}
\end{Declaration}
Geralmente, cada nível de seção recebe um número inteiro indicando sua
profundidade na estrutura do documento. \LaTeX{} precisa disso para gerenciar a hierarquia
dos níveis de seção. Mas normalmente esses valores são conhecidos apenas pela
classe particular que define os comandos de seção. Essa classe então usa os
números apropriados dentro dos comandos correspondentes.

O pacote \Package{scrlayer} também precisa de informações sobre a
hierarquia de seções. Com a ajuda de \Macro{DeclareSectionNumberDepth}, você pode mapear o
nome de um nível de título para uma \PName{profundidade de nível} correspondente. Por exemplo,
para a classe padrão \Class{book}, os \PName{nomes de nível}s seriam
\PValue{part}, \PValue{chapter}, \PValue{section}, \PValue{subsection},
\PValue{subsubsection}, \PValue{paragraph}, e \PValue{subparagraph}, e as
\PName{profundidades de nível}s correspondentes seriam -1, 0, 1, 2, 3, 4, e 5.

O pacote \Package{scrlayer} tenta determinar as \PName{profundidades de nível}s por
conta própria ao carregar e novamente durante \Macro{begin}\PParameter{document}. Mas
se isso falhar, por exemplo porque você usa comandos de secionamento completamente diferentes,
você pode definir o relacionamento explicitamente com
\Macro{DeclareSectionNumberDepth}.%
\EndIndexGroup


\section{Declarando Camadas}
\seclabel{layers}

Uma camada é um modelo abstrato de uma página. Ao contrário de uma folha real
de papel, essa página é completamente transparente. Normalmente, várias camadas são
empilhadas uma sobre a outra e material opaco em uma camada oculta material em
as camadas abaixo. A pilha de camadas é então mesclada para formar a
página física. O pacote \Package{scrlayer} fornece duas pilhas para cada página: uma
pilha de fundo e uma pilha de primeiro plano. A pilha de fundo é impressa
sob o conteúdo normal da página, enquanto a pilha de primeiro plano é impressa acima
dela. O conteúdo normal da página é, portanto, uma espécie de camada divisória entre
as duas pilhas de camadas.

Uma camada tem vários atributos que podem ser entendidos como respostas a algumas
questões básicas:
\iffree{\begin{description}}{%
    \begingroup
    \RedeclareSectionCommand[beforeskip=.5\baselineskip plus .25\baselineskip
    minus .1\baselineskip]{paragraph}%
    \renewcommand*\item[4][]{\paragraph*{#3{#4}#1}}%
  }%
\item[A camada pertence ao primeiro plano ou ao fundo?]%
  \leavevmode\textnote{primeiro plano ou fundo}\hskip 0pt
  Camadas de fundo são produzidas antes do conteúdo normal da página.
  Portanto, elas aparecem atrás ou sob o conteúdo normal da página.
  Camadas de primeiro plano são então produzidas após o conteúdo normal. Portanto, elas
  aparecem no topo do conteúdo normal da página. Por padrão, uma camada é
  \emph{e} uma camada de fundo \emph{e} uma camada de primeiro plano e, portanto, é impressa
  duas vezes. Geralmente faz sentido limitar a camada explicitamente a
  ou o primeiro plano ou o fundo.
\item[Qual é a posição da camada?]%
  \leavevmode\textnote{posição horizontal e vertical}\hskip 0pt
  Para responder a essa pergunta, há atributos para definir a
  posição horizontal e vertical da camada.
\item[Qual é o tamanho da camada?\textnote{tamanho horizontal e vertical}]%
  Como acontece com a posição, também há atributos para definir a largura e a
  altura de uma camada. Assim, uma camada pode ser menor ou maior que o papel
  e pode ser colocada em diferentes posições no papel.
\item[Como as posições horizontal e vertical são medidas?]%
  \leavevmode\textnote{alinhamento}\hskip 0pt
  Essa pergunta é respondida pelo atributo de alinhamento. A
  posição horizontal pode ser medida da borda esquerda do papel para a borda esquerda da
  camada, para o centro da camada, ou para a borda direita da camada.
  Da mesma forma, a posição vertical pode ser medida da borda superior do
  papel para a borda superior da camada, o centro da camada, ou a borda
  inferior da camada.
\item[A camada é destinada à saída de texto ou de imagens?]%
  \leavevmode\textnote{texto ou imagem}\hskip 0pt
  Essa pergunta está intimamente relacionada à posição. Por exemplo, os usuários geralmente
  esperam que a origem de uma imagem esteja no canto inferior esquerdo da camada.
  Mas isso não seria adequado para saída de texto. Portanto, a origem de uma
  camada de texto é a altura de uma linha de texto padrão abaixo do canto superior esquerdo
  da camada. Camadas de imagem, por outro lado, criam um ambiente
  \Environment{picture}\IndexEnv{picture} no qual comandos de
  posicionamento adicionais estão disponíveis.
\item[A camada deve ser impressa em páginas à esquerda ou à direita?]%
  \leavevmode\textnote{página à esquerda ou à direita}\hskip 0pt
  Por padrão, uma camada será impressa em todas as páginas. Observe que \LaTeX{} trata
  páginas pares como páginas do lado esquerdo e páginas ímpares como páginas do lado direito, mas em
  impressão unilateral, apenas páginas do lado direito existem independentemente do número da página.
\item[A camada deve ser impressa em modo unilateral ou bilateral?]%
  \leavevmode\textnote{unilateral ou bilateral}\hskip 0pt
  Por padrão, uma camada será impressa em impressão
  unilateral e bilateral. No entanto, uma camada que está restrita a páginas pares nunca
  será impressa em impressão unilateral e, portanto, não é uma camada unilateral.
\item[A camada deve ser impressa em páginas flutuantes ou normais?]%
  \leavevmode\textnote{página flutuante ou página normal}\hskip 0pt
  \LaTeX{} produz páginas flutuantes para objetos de ambientes como tabelas ou
  figuras se forem permitidas aparecer em uma página sem conteúdo normal da página
  (consulte a opção \PValue{p} para \Environment{figure} ou \Environment{table}). Em
  efeito, a página inteira pode flutuar dentro do documento. Páginas
  normais neste sentido são todas as páginas que não são páginas flutuantes. Páginas normais podem
  também conter flutuações no topo, no meio ou na base da página.
  Flutuações muito grandes podem dar a impressão de serem páginas flutuantes, enquanto em
  realidade são ambientes flutuantes colocados no topo de uma página normal.
\item[Qual é o conteúdo da camada?]%
  \leavevmode\textnote{conteúdo}\hskip 0pt
  O atributo correspondente simplesmente contém o que deve ser impresso sempre
  que a camada é produzida.
\iffree{\end{description}}{%
  \endgroup\par\bigskip\noindent\ignorespaces
}%
Essas oito questões imediatamente dão origem a vários atributos. Mais tarde
\iffree{neste guia}, descreveremos atributos adicionais. No entanto, eles
são definidos apenas por conveniência e podem ser expressos por uma combinação de
esses atributos primários.


\begin{Declaration}
  \Macro{DeclareLayer}\OParameter{lista de opções}\Parameter{nome da camada}%
  \Macro{DeclareNewLayer}\OParameter{lista de opções}\Parameter{nome da camada}%
  \Macro{ProvideLayer}\OParameter{lista de opções}\Parameter{nome da camada}%
  \Macro{RedeclareLayer}\OParameter{lista de opções}\Parameter{nome da camada}%
  \Macro{ModifyLayer}\OParameter{lista de opções}\Parameter{nome da camada}
\end{Declaration}
Esses comandos podem ser usados para definir camadas. O \PName{nome da camada} deve ser
totalmente expansível e deve expandir apenas para letras ASCII. Alguns caracteres
adicionais são aceitos, mas seu uso é recomendado apenas para usuários avançados.

O comando \Macro{DeclareLayer} não se importa se uma camada com o
\PName{nome da camada} fornecido já existe ou não. Sob todas as circunstâncias,
definirá a camada com os atributos especificados na \PName{lista de opções}. Uma
\PName{opção} pode ser uma chave ou uma chave seguida por um sinal de igualdade e
um valor. Múltiplas opções são separadas por vírgulas. Para usar uma vírgula ou um
espaço em branco dentro do valor de uma opção, você deve colocar o valor dentro de chaves.
Consulte \autoref{tab:scrlayer.layerkeys} para mais informações sobre chaves,
valores e os atributos correspondentes.

Ao contrário de \Macro{DeclareLayer}, \Macro{DeclareNewLayer} relata um erro se uma
camada com o mesmo \PName{nome da camada} já existe. Isso previne que o usuário
use acidentalmente o mesmo \PName{nome da camada} mais de uma vez. Isto
é especialmente útil quando classes ou pacotes também definem camadas internamente.

Em contraste, \Macro{ProvideLayer} apenas define uma camada se não houver camada
com o mesmo nome já. Se o nome está em uso para outra camada, a nova
definição é ignorada. Portanto, esse comando tem o significado, \emph{definir
	a camada apenas se ela ainda não existir.}

Se você quiser redefinir uma camada existente, pode usar \Macro{RedeclareLayer}
ou \Macro{ModifyLayer}. Com \Macro{RedeclareLayer}, a camada é primeiro redefinida
para as configurações padrão e depois completamente redefinida através da
lista de opções especificada. Em contraste, \Macro{ModifyLayer} não redefine a camada.
Apenas aqueles atributos que estão explicitamente definidos na \PName{lista de opções} serão
alterados. Aplicar qualquer comando a um \PName{nome de camada}
previamente indefinido resulta em um erro.

\begin{desclist}
  \desccaption{%
    Opções para definir camadas de página e o significado do
    atributo de camada correspondente\label{tab:scrlayer.layerkeys}%
  }{%
    Opções para definir camadas (\emph{continuação})%
  }%
  \entry{%
    \ChangedAt{v3.16}{\Package{scrlayer}}%
    \OptionVName{addcontents}{Código}}{%
    O \PName{código} especificado será anexado ao valor atual do
    atributo \Option{contents}, então o novo conteúdo aparecerá no final do
    conteúdo existente. Para mais informações sobre o tratamento de
    \PName{código}, consulte a opção \Option{contents}.%
  }%
  \entry{%
    \ChangedAt{v3.16}{\Package{scrlayer}}%
    \OptionVName{addheight}{altura adicional}}{%
    O valor atual do atributo \Option{height} será aumentado pelo
    valor desta opção. Você pode usar o mesmo tipo de valores que para
    \Option{height}.%
  }%
  \entry{%
    \ChangedAt{v3.16}{\Package{scrlayer}}%
    \OptionVName{addhoffset}{deslocamento horizontal adicional}}{%
    O valor atual do atributo \Option{hoffset} será aumentado pelo
    valor desta opção. Você pode usar o mesmo tipo de valores que para
    \Option{hoffset}.%
  }%
  \entry{%
    \ChangedAt{v3.16}{\Package{scrlayer}}%
    \OptionVName{addvoffset}{deslocamento vertical adicional}}{%
    O valor atual do atributo \Option{voffset} será aumentado pelo
    valor desta opção. Você pode usar o mesmo tipo de valores que para
    \Option{voffset}.%
  }%
  \entry{%
    \ChangedAt{v3.16}{\Package{scrlayer}}%
    \OptionVName{addwidth}{largura adicional}}{%
    O valor atual do atributo \Option{width} será aumentado pelo
    valor desta opção. Você pode usar o mesmo tipo de valores que para
    \Option{width}.%
  }%
  \nentry{\KOption{align}{\PName{caracteres de alinhamento}}}{%
    Os \PName{caracteres de alinhamento} definem o alinhamento desejado da
    camada. Cada \PName{caractere de alinhamento} determina como o \PName{comprimento}
    de \Option{hoffset} ou da opção \Option{voffset} é
    interpretado. Múltiplos \PName{caracteres de alinhamento}s podem ser usados juntos
    (sem espaços ou vírgulas) e são avaliados na ordem em que ocorrem.
    Macros não são permitidas no valor da opção. Os \PName{caracteres de alinhamento}s válidos são:
    \begin{description}
    \item[\PValue{b} --] alinhar a camada em sua borda inferior; o valor de
      \Option{voffset} é a distância da borda superior do papel para a
      base da camada.
    \item[\PValue{c} --] alinhar a camada em seu centro; os valores de
      \Option{voffset} e \Option{hoffset} são interpretados como a distância
      do canto superior esquerdo do papel para o centro da camada.
    \item[\PValue{l} --] alinhar a camada em sua borda esquerda; o valor de
      \Option{hoffset} é interpretado como a distância da borda esquerda do
      papel para a borda esquerda da camada.
    \item[\PValue{r} --] alinhar a camada em sua borda direita; o valor de
      \Option{hoffset} é interpretado como a distância da borda esquerda do
      papel para a borda direita da camada.
    \item[\PValue{t} --] alinhar a camada em sua borda superior; o valor de
      \Option{voffset} é interpretado como a distância da borda superior do
      papel para a borda superior da camada.
    \end{description}%
  }%
  \entry{\KOption{area}{%
      \Parameter{hoffset}\Parameter{voffset}%
      \Parameter{width}\Parameter{height}}}{%
    Esta opção composta define os atributos primários
    \OptionValue{hoffset}{deslocamento horizontal}, \OptionValue{voffset}{deslocamento
      vertical}, \OptionValue{width}{largura}, \OptionValue{height}{altura}.%
  }%
  \entry{\ChangedAt{v3.18}{\Package{scrlayer}}%
    \Option{backandforeground}}{%
    Esta opção remove a restrição de uma camada ao primeiro plano ou
    fundo. Em geral, essa opção faz pouco sentido, mas é fornecida
    para completar uma interface de usuário completa. Esta opção não espera nem
    permite um valor.%
  }%
  \entry{\Option{background}}{%
    Esta opção exibe a camada apenas no fundo. O padrão é
    exibir camadas em fundo e primeiro plano. Esta opção não
    espera nem permite um valor.%
  }%
  \entry{\Option{bottommargin}}{%
    Esta opção composta define os atributos primários \Option{hoffset},
    \Option{voffset}, \Option{width}, \Option{height}, e \Option{align} para
    que a camada se estenda pelo papel horizontalmente da borda esquerda para a
    direita e verticalmente imediatamente abaixo do rodapé até a borda
    inferior do papel.%
  }%
  \entry{\KOption{clone}{\PName{nome da camada}}}{%
    Esta opção composta define todos os atributos primários da camada com os mesmos
    valores que os atributos primários da camada com o \PName{nome da camada}
    fornecido. Consulte as notas sobre \PName{nome da camada} no início da
    explicação para \Macro{DeclareLayer}. A camada a ser clonada também deve
    já existir.%
  }%
  \entry{\KOption{contents}{\PName{código}}}{%
    O \PName{código} especificado será expandido sempre que a camada for impressa.
    Este \PName{código} define o que você vê para a camada. Nenhum teste é feito para
    ver se o código é válido. Erros no \PName{código} podem, portanto, levar a
    múltiplas mensagens de erro em cada página que imprime a camada.%
  }%
  \entry{\Option{evenpage}}{%
    Esta opção faz com que a camada apareça apenas em páginas pares, ao contrário do
    padrão, onde uma camada aparecerá em páginas pares e ímpares. Como páginas
    pares aparecem apenas em impressão bilateral, esta opção implica
    \Option{twoside}. Esta opção não espera nem permite um valor.%
  }%
  \entry{\ChangedAt{v3.18}{\Package{scrlayer}}%
    \Option{everypage}}{%
    Esta opção é uma combinação de \Option{oddorevenpage} e
    \Option{floatornonfloatpage}. Esta opção não espera nem permite um
    valor.%
  }%
  \entry{\Option{everyside}}{%
    Esta opção remove qualquer restrição de camada à impressão unilateral ou bilateral.
    Esta é a configuração padrão. Esta opção não espera nem
    permite um valor.%
  }%
  \entry{\ChangedAt{v3.18}{\Package{scrlayer}}%
    \Option{floatornonfloatpage}}{%
    Esta opção remove qualquer restrição de camada a páginas flutuantes ou não flutuantes
    e restaura a configuração padrão. Esta opção não espera nem
    permite um valor.%
  }%
  \entry{\Option{floatpage}}{%
    Esta opção restringe a camada a aparecer apenas em páginas flutuantes. A
    configuração padrão é para camadas aparecerem em páginas flutuantes e não flutuantes.
    Esta opção não espera nem permite um valor.%
  }%
  \entry{\Option{foot}}{%
    Esta opção composta define \Option{hoffset}, \Option{voffset},
    \Option{width}, \Option{height}, e \Option{align} para que a camada
    se estenda pelo rodapé da página sobre a largura da área de texto. Esta opção não
    espera nem permite um valor.%
  }%
  \entry{\Option{footskip}}{%
    Esta opção composta define \Option{hoffset}, \Option{voffset},
    \Option{width}, \Option{height}, e \Option{align} para que a camada
    se estenda pela distância vertical entre a área de texto e o rodapé da página sobre
    a largura da área de texto. Observe, porém, que embora a altura de
    esta área dependa de \Length{footskip}, não é o mesmo. Esta opção
    não espera nem permite um valor.%
  }%
  \entry{\Option{foreground}}{%
    Esta opção exibe a camada apenas no primeiro plano. O padrão é
    exibir camadas em fundo e primeiro plano. A opção não
    espera nem permite um valor.%
  }%
  \entry{\Option{head}}{%
    Esta opção composta define \Option{hoffset}, \Option{voffset},
    \Option{width}, \Option{height}, e \Option{align} para que a camada
    se estenda pela área vertical do cabeçalho da página para a largura da área de texto.
    A altura corresponde ao comprimento \Length{headheight}. Esta opção não
    espera nem permite um valor.%
  }%
  \entry{\Option{headsep}}{%
    Esta opção composta define \Option{hoffset}, \Option{voffset},
    \Option{width}, \Option{height}, e \Option{align} para que a camada
    se estenda pela distância vertical entre o cabeçalho da página e a área de texto para
    a largura da área de texto. A altura corresponde ao comprimento
    \Length{headsep}. Esta opção não espera nem permite um valor.%
  }%
  \entry{\KOption{height}{\PName{comprimento}}}{%
    Define a altura da camada. Observe que o \PName{comprimento} pode ser
    um comprimento \LaTeX{} declarado com \Macro{newlength}, um comprimento \TeX{} declarado
    com \Macro{newdimen} ou \Macro{newskip}, um valor de comprimento como 10\,pt, ou uma
    expressão dimensional usando +, -, /, *, (, e ). Para mais informações
    sobre expressões dimensionais válidas, consulte \cite[section~3.5]{manual:eTeX}.%
  }%
  \entry{\KOption{hoffset}{\PName{comprimento}}}{%
    Define a distância da camada da borda esquerda do papel. Como a
    distância é medida depende da opção \Option{align}. Consulte a
    opção \Option{height} para mais informações sobre expressões válidas para
    \PName{comprimento}.%
  }%
  \entry{\Option{innermargin}}{%
    Esta opção composta define \Option{hoffset}, \Option{voffset},
    \Option{width}, \Option{height}, e \Option{align} para que a camada
    se estenda pela margem interna, da borda da página até a borda da área de texto
    e do topo até a base da página. Em impressão unilateral,
    a margem interna corresponde à margem esquerda. Esta opção não
    espera nem permite um valor.%
  }%
  \entry{\Option{leftmargin}}{%
    Esta opção composta define \Option{hoffset}, \Option{voffset},
    \Option{width}, \Option{height}, e \Option{align} para que a camada
    se estenda pela margem esquerda, da borda esquerda do papel até a borda esquerda da
    área de texto e do topo do papel para baixo. Esta opção
    não espera nem permite um valor.%
  }%
  \entry{\ChangedAt{v3.19}{\Package{scrlayer}}%
    \OptionVName{mode}{modo}}{%
    Esta opção primária define o \PName{modo} em que o conteúdo da camada é
    produzido. O padrão é \OptionValue{mode}{text}. A linha de base da
    primeira linha de texto é colocada na altura de uma linha de texto padrão abaixo da
    borda superior da camada, para que o texto geralmente seja bem alinhado com o topo
    da camada. Em \PValue{picture} \PName{modo}, por outro lado, a
    camada ocupa um ambiente \Environment{picture} com a origem no
    canto inferior esquerdo da camada. O \PValue{raw} \PName{modo} também
    está definido. Por padrão corresponde ao \PValue{text} \PName{modo}.
    Alterar\textnote{Atenção!} o \PName{modo} de uma camada geralmente resulta
    em deslocamento de conteúdo. Além disso, o \PValue{picture} \PName{modo}
    fornece comandos adicionais que resultam em erros com outro
    \PName{modo}. Portanto, geralmente não faz sentido alterar o
    \PName{modo} de uma camada após sua declaração inicial!%
  }%
  \entry{\Option{nonfloatpage}}{%
    Esta opção restringe a camada a páginas que não são páginas flutuantes. O
    padrão é para a camada aparecer em páginas flutuantes e não flutuantes. Esta
    opção não espera nem permite um valor.%
  }%
  \entry{\ChangedAt{v3.18}{\Package{scrlayer}}%
    \Option{oddorevenpage}}{%
    Esta opção remove qualquer restrição de camada a páginas ímpares ou pares,
    restaurando o comportamento padrão que a camada deve aparecer em páginas
    pares e ímpares. A opção não espera nem permite um valor.%
  }%
  \entry{\Option{oddpage}}{%
    Esta opção restringe a camada apenas a páginas ímpares. O padrão é para
    camadas aparecerem em páginas pares e ímpares. Observe que em
    impressão unilateral, todas as páginas são ímpares, independentemente do número da página. Esta
    opção não espera nem permite um valor.%
  }%
  \entry{\Option{oneside}}{%
    Esta opção restringe a camada apenas a impressão unilateral. O padrão é
    para camadas aparecerem em impressão unilateral e bilateral. Esta opção
    não espera nem permite um valor.%
  }%
  \entry{\Option{outermargin}}{%
    A opção composta define \Option{hoffset}, \Option{voffset},
    \Option{width}, \Option{height}, e \Option{align} para que a camada
    se estenda pela margem externa da página, do topo até a base do
    papel. A margem externa corresponde à margem direita em
    impressão unilateral. Esta opção não espera nem permite um valor.%
  }%
  \entry{\Option{page}}{%
    Esta opção composta define \Option{hoffset}, \Option{voffset},
    \Option{width}, \Option{height}, e \Option{align} para que a camada
    se estenda pelo papel inteiro. Esta opção não espera nem permite um valor.%
  }%
  \entry{\ChangedAt{v3.16}{\Package{scrlayer}}%
    \OptionVName{pretocontents}{código}}{%
    O valor de \PName{código} é adicionado como prefixo ao valor atual do
    atributo \Option{contents}, para que o novo conteúdo apareça antes do
    conteúdo existente. Para mais informações sobre o tratamento de \PName{código},
    consulte a opção \Option{contents}.%
  }%
  \entry{\Option{rightmargin}}{%
    Esta opção composta define \Option{hoffset}, \Option{voffset},
    \Option{width}, \Option{height}, e \Option{align} para que a camada
    se estenda pela margem direita, da borda direita da área de texto até a borda
    direita do papel e do topo até a borda inferior do papel. Esta
    opção não espera nem permite um valor.%
  }%
  \entry{\Option{textarea}}{%
    Esta opção composta define \Option{hoffset}, \Option{voffset},
    \Option{width}, \Option{height}, e \Option{align} para que a camada
    se estenda por toda a área de texto. Esta opção não espera nem permite um valor.%
  }%
  \entry{\Option{topmargin}}{%
    Esta opção composta define \Option{hoffset}, \Option{voffset},
    \Option{width}, \Option{height}, e \Option{align} para que a camada
    se estenda pela distância vertical da borda superior do papel até o
    cabeçalho por toda a largura do papel. Esta opção não espera nem
    permite um valor.%
  }%
  \entry{\Option{twoside}}{%
    Esta opção restringe a camada à impressão bilateral. O padrão é para
    camadas aparecerem em impressão unilateral e bilateral. Esta opção
    não espera nem permite um valor.%
  }%
  \entry{\ChangedAt{v3.18}{\Package{scrlayer}}%
    \Option{unrestricted}}{%
    Esta opção remove todas as restrições de saída. É uma combinação de
    \Option{backandforeground}, \Option{everyside}, e
    \Option{floatornonfloatpage}. Esta opção não espera nem permite um
    valor.%
  }%
  \entry{\KOption{voffset}{\PName{comprimento}}}{%
    Define a distância da camada do topo do papel. Como a distância
    é medida depende da opção \Option{align}. Consulte a
    opção \Option{height} para mais informações sobre expressões válidas para \PName{comprimento}.%
  }%
  \entry{\KOption{width}{\PName{comprimento}}}{%
    Define a largura da camada. Consulte a opção \Option{height} para mais
    informações sobre expressões válidas para \PName{comprimento}.%
  }%
\end{desclist}
%
\EndIndexGroup


\begin{Declaration}
  \Macro{ModifyLayers}\OParameter{lista de opções}\Parameter{lista de camadas}
\end{Declaration}
Este\ChangedAt{v3.26}{\Package{scrlayer}} comando executa
\DescRef{\LabelBase.cmd.ModifyLayer} com a \PName{lista de opções} fornecida para
todas as camadas da lista de camadas separada por vírgulas. Portanto, a opção pode ser usada
para alterar atributos de várias camadas simultaneamente.%
\EndIndexGroup


\begin{Declaration}
  \Macro{layerhalign}%
  \Macro{layervalign}%
  \Macro{layerxoffset}%
  \Macro{layeryoffset}%
  \Macro{layerwidth}%
  \Macro{layerheight}%
\end{Declaration}
Esses comandos são válidos apenas no \PName{código} especificado com
\Option{contents}, \Option{addcontents}, ou \Option{pretocontents}. Neste
caso, eles contêm o alinhamento real da camada, posição e dimensões que
serão usadas para a saída. No entanto, isso não é necessariamente a
dimensão real do conteúdo da camada, por exemplo, se o conteúdo for supersizado ou
não preencher a camada completamente.

O atributo de camada primária \PValue{align} é mapeado para
\Macro{layerhalign}\ChangedAt{v3.19}{\Package{scrlayer}} e
\Macro{layervalign}. Os valores horizontais \PValue{l} e \PValue{r} são
copiados para \Macro{layerhalign}. Os valores verticais \PValue{t} e \PValue{b}
são copiados para \Macro{layervalign}. O valor \PValue{c}, que é tanto
horizontal quanto vertical, é copiado para ambos os comandos. Se houver vários
valores conflitantes para \PValue{align}, apenas o último é copiado. Assim, o
\Macro{layerhalign} resultante é \PValue{l}, \PValue{c}, ou \PValue{r},
e o \Macro{layervalign} resultante é \PValue{t}, \PValue{c}, ou
\PValue{b}.

Redefinir\textnote{Atenção!} essas instruções para alterar os valores armazenados
nelas não é permitido, pois levaria a resultados imprevisíveis.%
\EndIndexGroup


\begin{Declaration}
  \Macro{LenToUnit}\Parameter{comprimento}
\end{Declaration}
Este\ChangedAt{v3.19}{\Package{scrlayer}} comando originalmente veio de
\Package{eso-pic}\IndexPackage{eso-pic}~2.0f. Converte comprimentos em
múltiplos de \Length{unit length} e pode, portanto, ser usado em qualquer lugar que \LaTeX{}
espera coordenadas \Environment{picture} ou valores dependentes de
\Length{unit length}. Para mais informações, consulte \cite{package:eso-pic} e as descrições
de \Macro{putUR}, \Macro{putLL}, e \Macro{putLR} abaixo. Se o comando já
for definido, por exemplo, ao carregar \Package{eso-pic} antes de
\Package{scrlayer}, o pacote não o define novamente.%
\iffalse% Umbruchkorrekturtext
\par
Deve-se notar neste ponto que usar o pacote
\Package{picture}\IndexPackage{picture}\important{\Package{picture}} (consulte
\cite{package:picture}) substitui \Macro{LenToUnit} mais ou menos. O pacote
estende o ambiente \Environment{picture} e os comandos de imagem para que você
possa usar comprimentos \LaTeX{} diretamente para coordenadas.%
\fi
\EndIndexGroup


\begin{Declaration}
  \Macro{putUL}\Parameter{conteúdo}%
  \Macro{putUR}\Parameter{conteúdo}%
  \Macro{putLL}\Parameter{conteúdo}%
  \Macro{putLR}\Parameter{conteúdo}%
  \Macro{putC}\Parameter{conteúdo}
\end{Declaration}
Você\ChangedAt{v3.19}{\Package{scrlayer}} pode usar esses comandos dentro do
valor da opção de camada \PValue{contents} se a camada for declarada com
\OptionValue{mode}{picture}. Neste caso, \Macro{putUL} coloca o
\PName{conteúdo} relativo ao canto superior esquerdo da camada e, portanto,
é o mesmo que
\lstinline[breaklines=false]|\put(0,\LenToUnit{\layerheight})|. \Macro{putUR}
coloca o \PName{conteúdo} relativo ao canto superior direito da camada e
portanto é o mesmo que
\lstinline[breaklines=false]
|\put(\LenToUnit{\layerwidth},\LenToUnit{\layerheight})|.
\Macro{putLL} coloca o \PName{conteúdo} relativo ao canto inferior esquerdo da
camada e portanto é o mesmo que
\lstinline[breaklines=false]|\put(0,0)|. \Macro{putLR} coloca o
\PName{conteúdo} relativo ao canto inferior direito e portanto é o mesmo
que \lstinline[breaklines=false]|\put(\LenToUnit{\layerwidth},0)|. Por fim,
\Macro{putC} coloca o \PName{conteúdo} relativo ao centro da
camada.%
\begin{Example}
  Você quer determinar exatamente com que precisão
  \OptionValueRef{typearea}{DIV}{classic} define a altura da área de texto para
  a largura do tamanho da página. Você declara uma camada que tanto bordeja a
  área de texto quanto coloca um círculo com um diâmetro da largura do papel no centro da
  área de texto:
\begin{lstcode}
  \documentclass[DIV=classic]{scrartcl}
  \usepackage{pict2e}
  \usepackage{scrlayer}
  \DeclareNewLayer[%
    textarea,background,mode=picture,
    contents={%
      \putLL{\line(1,0){\LenToUnit{\layerwidth}}}%
      \putLR{\line(0,1){\LenToUnit{\layerheight}}}%
      \putUR{\line(-1,0){\LenToUnit{\layerwidth}}}%
      \putUL{\line(0,-1){\LenToUnit{\layerheight}}}%
      \putC{\circle{\LenToUnit{\paperwidth}}}%
    }
  ]{showtextarea}
  \DeclareNewPageStyleByLayers{test}{showtextarea}
  \pagestyle{test}
  \begin{document}
  \null
  \end{document}
\end{lstcode}
  Você notará que o mapeamento de \Package{typearea} para um valor inteiro \PName{DIV}
  é muito preciso neste exemplo.
\end{Example}
Aliás, você encontrará mais informações sobre o cânone de página de livro medieval tardio
esboçado no exemplo em \autoref{sec:typearea.circleConstruction},
\autopageref{sec:typearea.circleConstruction}.

O \Macro{DeclareNewPageStyleByLayers}\IndexCmd{DeclareNewPageStyleByLayers}
comando que foi usado no exemplo define um novo estilo de página usando a camada
recém-declarada. Será explicado em \autoref{sec:scrlayer.pagestyles},
\DescPageRef{scrlayer.cmd.DeclareNewPageStyleByLayers}.%
\EndIndexGroup


\begin{Declaration}
  \Macro{GetLayerContents}\Parameter{nome~da~camada}
\end{Declaration}
Este\ChangedAt{v3.16}{\Package{scrlayer}} comando retorna todo o conteúdo
de uma camada. É importante observar\textnote{Atenção!} que usar este
comando dentro do \PName{código} dos atributos de camada \Option{contents},
\Option{addcontents}, ou \Option{pretocontents} pode resultar em
recursão infinita ao referenciar o conteúdo da camada atual. Você
é responsável por evitar essas situações!%
\EndIndexGroup


\begin{Declaration}
  \Macro{IfLayerExists}\Parameter{nome~da~camada}
                       \Parameter{código-então}\Parameter{código-senão}
\end{Declaration}
Este comando pode ser usado para executar código dependendo de se uma camada
com o \PName{nome da camada} especificado existe ou não. Se a camada existir, o
\PName{código-então} será executado; caso contrário, o \PName{código-senão} será
executado. Observe que o comando não pode realmente testar se uma camada existe.
Em vez disso, ele usa uma heurística que nunca produzirá um falso negativo, mas que,
em casos extremos, poderia produzir um falso positivo.
\iffalse% Umbruchvarianten
Não obstante, se o teste produzir um falso positivo, algo deu errado.
Por exemplo, isso poderia indicar um pacote incompatível ou que o usuário está
fazendo algo que não deveria.%
\else
Falsos positivos indicam um problema, como o uso de um pacote incompatível
ou uma má escolha de nomes de macro internos pelo usuário.
\fi
\EndIndexGroup


\begin{Declaration}
  \Macro{DestroyLayer}\Parameter{nome~da~camada}
\end{Declaration}
Se uma camada com o \PName{nome da camada} fornecido existir, todas as macros a ela
pertencentes serão definidas como \Macro{relax}. Em estilos de página já definidos com
\Package{scrlayer}, essas camadas destruídas são ignoradas. Camadas destruídas podem ser
redefinidas usando \DescRef{\LabelBase.cmd.DeclareNewLayer} ou
\DescRef{\LabelBase.cmd.ProvideLayer}, mas não podem mais ser alteradas usando
\DescRef{\LabelBase.cmd.RedeclareLayer} ou
\DescRef{\LabelBase.cmd.ModifyLayer}.%
\iffalse % See the note at the beginning of the end user interface section
\par
The command is intended to be used inside
\DescRef{\LabelBase.cmd.scrlayerOnAutoRemoveInterface} (see
\autoref{sec:scrlayer.enduserinterfaces},
\DescPageRef{scrlayer.cmd.scrlayerOnAutoRemoveInterface})
to remove layers defined using removable macros of an interface along with
that interface.%
\fi
\EndIndexGroup


\begin{Declaration}
  \OptionVName{draft}{simples comutador}
  \Macro{layercontentsmeasure}%
\end{Declaration}
A opção \KOMAScript{} \Option{draft} pode ser usada para ativar o modo rascunho
de \Package{scrlayer}. O modo rascunho usa o comando
\Macro{layercontentsmeasure} para imprimir uma régua em cada borda da camada, sendo que a
superior e a esquerda são marcadas em centímetros e a direita e a inferior em polegadas. As réguas são
desenham atrás do conteúdo de cada camada. Este comando também pode ser usado como
conteúdo exclusivo de uma camada.%
\EndIndexGroup


\section{Declarando e Gerenciando Estilos de Página}
\seclabel{pagestyles}

\BeginIndexGroup
\BeginIndex{}{page>style}%
Agora entendemos como definir e gerenciar camadas, mas até agora não sabemos
como elas são usadas. A resposta possivelmente surpreendente é: com estilos de página. Em
\LaTeX{}, estilos de página geralmente definem cabeçalhos e rodapés da página.

The header and footer of odd or right-hand pages\textnote{even or odd page}
are printed on pages with odd page numbers in two-sided printing or on all
pages in one-sided printing. This is directly comparable to the layer 
options\important[i]{\Option{evenpage}\\\Option{oddpage}} \Option{oddpage} and
\Option{evenpage}.

The page header\textnote{header or footer} is output before the main page
contents. The page footer is output after the main page contents. This
corresponds directly to the layer
options\important[i]{\Option{background}\\\Option{foreground}}
\Option{background} and \Option{foreground}.

Therefore it makes sense to define page styles as lists of layers. But instead
of just the four options mentioned above, you can use all the properties
explained in \autoref{sec:scrlayer.layers}, \autoref{tab:scrlayer.layerkeys}, 
on \autopageref{tab:scrlayer.layerkeys}.

As a result of these considerations, layer page
styles\textnote{layer page style}\Index{page style>layer}%
\Index{layer>page style}\Index{page>style} are one type of page style that 
\Package{scrlayer} provides. A layer page style consists of layers as well as
several hooks. The layers have already been described in
\autoref{sec:scrlayer.layers}. The hooks\Index[indexmain]{hooks}%
\textnote{hooks} are points in the expansion or execution of page styles to
which you can add code. Experienced users already know this concept from
commands like \Macro{AtBeginDocument} (see \cite{latex:usrguide}) or
\DescRef{scrlfile.cmd.BeforeClosingMainAux} (see
\DescPageRef{scrlfile.cmd.BeforeClosingMainAux}).

Page-style aliases are another type of page style which \Package{scrlayer}
provides. A page-style alias is actually a different page style. In other
words, the name of a page-style alias is an alternative name for another
page-style alias or for a page style. As a result, manipulating a page-style
alias results in manipulating the original page style. If the original page
style is itself an alias, its manipulation again results in the manipulation
of the alias's original page style, and so on until a real page style is
finally changed. The term \emph{real page style}\textnote{real page style} is
used to distinguish it from a page-style alias. All page styles that are not
page-style aliases are real page styles. Aliases can be defined for all page
styles, not just those defined with \Package{scrlayer}.

\begin{Declaration}
  \Macro{currentpagestyle}
  \Macro{toplevelpagestyle}
\end{Declaration}
The \Package{scrlayer} package patches the \DescRef{maincls.cmd.pagestyle}
command so that it sets \Macro{currentpagestyle} to the currently active page
style. Note that \DescRef{maincls.cmd.thispagestyle} does not change
\Macro{currentpagestyle}. If you use \DescRef{maincls.cmd.thispagestyle},
however, \Macro{currentpagestyle} can change within the \LaTeX{} output
routine. However, this change will only occur if \Macro{currentpagestyle} has
been actively protected from expansion until the execution of the output
routine.

Note that the layer page styles described later in this section do not rely on
this \DescRef{maincls.cmd.pagestyle} extension because they redefine
\Macro{currentpagestyle} themselves. This patch was made so that other,
non-\Package{scrlayer} page styles can use \Macro{currentpagestyle}.
Additionally, \Macro{currentpagestyle} is empty after loading
\Package{scrlayer} and before using \DescRef{maincls.cmd.pagestyle} for the
first time. Therefore, when defining an end-user interface, you may find it
useful to set the current page style to a default with an implicit
\DescRef{maincls.cmd.pagestyle} statement.

If \DescRef{maincls.cmd.pagestyle} activates an alias page style,
\Macro{currentpagestyle} shows not the alternative name but the name of
the real page style. You\ChangedAt{v3.16}{\Package{scrlayer}} can get the
alternative name using \Macro{toplevelpagestyle}. However, it is not
recommended to define page styles that produce different results depending on
\Macro{toplevelpagestyle}, e.\,g., using \DescRef{scrbase.cmd.Ifstr}. If you
were to activate such a page style using \DescRef{maincls.cmd.thispagestyle}
you could get the wrong result.%
\EndIndexGroup


\begin{Declaration}
  \Macro{BeforeSelectAnyPageStyle}\Parameter{code}%
  \Macro{AfterSelectAnyPageStyle}\Parameter{code}%
\end{Declaration}
The \Macro{BeforeSelectAnyPageStyle} command adds \PName{code} to the hook%
\textnote{hook} that will be executed inside \DescRef{maincls.cmd.pagestyle},
just before the page style is selected. Within the \PName{code}, you can use
\texttt{\#1} as a place-holder for the argument of
\DescRef{maincls.cmd.pagestyle}.

The \Macro{AfterSelectAnyPageStyle} command works similarly, but the
\PName{code} will be executed just after the page style has been selected and
after \DescRef{\LabelBase.cmd.currentpagestyle} has been set to the name of
the real page style.

Note\textnote{Attention!} that the \PName{code} of both commands is executed
only if a page style is selected with \DescRef{maincls.cmd.pagestyle} and not
if it is chosen in a different way, e.\,g., using
\DescRef{maincls.cmd.thispagestyle}. Note also that you cannot remove
\PName{code} from the hook after adding it. But the \PName{code} will be added
locally, so you can use a group to limit the scope of the \PName{code}.%
\EndIndexGroup


\begin{Declaration}
  \Macro{DeclarePageStyleAlias}\Parameter{page~style~alias~name}
                               \Parameter{original~page~style~name}
  \Macro{DeclareNewPageStyleAlias}\Parameter{page~style~alias~name}
                                  \Parameter{original~page~style~name}
  \Macro{ProvidePageStyleAlias}\Parameter{page~style~alias~name}
                               \Parameter{original~page~style~name}
  \Macro{RedeclarePageStyleAlias}\Parameter{page~style~alias~name}
                                 \Parameter{original page style name}
\end{Declaration}
\BeginIndex{}{page style>alias}%
\BeginIndex{}{alias>page style}%
These commands can be used to define a page style with name \PName{page style
  alias name} that is simply an alias for an existing page style with the
name \PName{original page style name}. If there is already a page style
\PName{page style alias name}, using \Macro{DeclarePageStyleAlias} or
\Macro{RedeclarePageStyleAlias} will destroy the alias before recreating it.

\Macro{DeclareNewPageStyleAlias} will throw an error message if a page style
\PName{page style alias name} has already been defined. It does not matter if
the previously defined page style is a layer-page style, a page style alias,
or another page style.

\Macro{ProvidePageStyleAlias} will define the alias only if the
\PName{page style alias name} page style has not been defined before. If the
\PName{page style alias name} page style already exists, nothing will be done.

\Macro{RedeclarePageStyleAlias} expects an existing
\PName{page style alias name} page style. It will destroy that page style and
afterwards define the alias. If the \PName{page style alias name} page style
does not exist, you will get an error.%
\iffree{\csname @tempswafalse\endcsname}{\csname @tempswatrue\endcsname}%
\csname if@tempswa\endcsname% Umbruchkorrekturtext
  \begin{Example}
    Suppose you write a class and use the \PageStyle{chapter} page style for the
    first page of each chapter. By default, this page style should match the
    \PageStyle{plain} page style. Therefore, you can use the \Package{scrlayer}
    package and use
\begin{lstcode}
  \DeclareNewPageStyleAlias{chapter}{plain}
\end{lstcode}
    to define the \PageStyle{chapter} page style as an alias for the
    \PageStyle{plain} page style. If, on the other hand, you later decide that
    the \PageStyle{chapter} plage style should correspond to the
    \PageStyle{empty} page style, you can achieve this with:
\begin{lstcode}
  \RedeclarePageStyleAlias{chapter}{empty}
\end{lstcode}%
  \end{Example}%
\fi
\EndIndexGroup


\begin{Declaration}
  \Macro{DestroyPageStyleAlias}\Parameter{page~style~name}%
\end{Declaration}
\BeginIndex{}{page style>alias}%
\BeginIndex{}{alias>page style}%
This command renders the page style named \PName{page style name} undefined
for \LaTeX{} if it is an alias for another page style. Afterwards, the page
style can be newly defined with
\DescRef{\LabelBase.cmd.DeclareNewPageStyleAlias} or
\DescRef{\LabelBase.cmd.ProvidePageStyleAlias}.%
\iffalse % See the note at the beginning of the end user interface section
\par
This command is intended to be used inside the argument code of
\DescRef{\LabelBase.cmd.scrlayerOnAutoRemoveInterface} to remove page styles
that have been declared as part of an end-user interface when removing this
interface automatically.%
\fi%
\EndIndexGroup


\begin{Declaration}
  \Macro{GetRealPageStyle}\Parameter{page~style~name}%
\end{Declaration}
\BeginIndex{}{page style>alias}%
\BeginIndex{}{alias>page style}%
This command will result in the (recursive) real page name of the page style
if \PName{page style name} is an alias of another page style. In all other
cases, even if there's no alias and no page style named \PName{page style
  name}, the result is simply \PName{page style name}. The command is fully
expandable and may be used, e.g., in the second argument of \Macro{edef}.%
\EndIndexGroup


\begin{Declaration}
  \Macro{DeclarePageStyleByLayers}\OParameter{option list}
                                  \Parameter{page style name}
                                  \Parameter{layer list}
  \Macro{DeclareNewPageStyleByLayers}\OParameter{option list}
                                     \Parameter{page style name}
                                     \Parameter{layer list}
  \Macro{ProvidePageStyleByLayers}\OParameter{option list}
                                  \Parameter{page style name}
                                  \Parameter{layer list}
  \Macro{RedeclarePageStyleByLayers}\OParameter{option list}
                                    \Parameter{page style name}
                                    \Parameter{layer list}
\end{Declaration}
\BeginIndex{}{page style>layers}%
\BeginIndex{}{layers>page style}%
These commands declare a page style named \PName{page style name}. The page
style will consist of the layers given in \PName{layer list}, a comma
separated list of layer names. Note\textnote{Attention!} that the \PName{page
  style name} and the layer names in the \PName{layer list} must be fully
expandable and should expand to letters. Several other characters are also
accepted, but their use is recommended only for experienced users.

The \PName{option list} is a comma-separated list of options in the form
\texttt{\PName{key}=\PName{value}}. These options may be used to set
additional features. Currently they are used to set the code that should be
expanded or executed at several hooks\Index{hooks}. See the introduction to
this section for more general information about hooks. See
\autoref{tab:scrlayer.pagestyle.hooks} for detailed information on specific
hooks.

\begin{desclist}
  \desccaption{%
    Hook options for page styles (in order of
    execution)\label{tab:scrlayer.pagestyle.hooks}%
  }{%
    Hook options for page styles (\emph{continued})%
  }%
  \entry{\OptionVName{onselect}{code}}{%
    The \PName{code} of this hook\Index{hook} is executed whenever the page
    style is selected, for example with \DescRef{maincls.cmd.pagestyle}. Note
    that \DescRef{maincls.cmd.thispagestyle} itself does not directly select a
    page style. In this case, the page style is only activated within \LaTeX's
    output routine.%
  }%
  \entry{\OptionVName{oninit}{code}}{%
    The \PName{code} of this hook\Index{hook} is executed whenever the output
    of the page style's layers is initialised. Note that this happens twice
    for each page: once for background layers and once for foreground layers.%
  }%
  \entry{\OptionVName{ononeside}{code}}{%
    The \PName{code} of this hook\Index{hook} is executed whenever the output
    of the page style's layers in one-sided printing is initialised. Note that
    this happens twice for each page: once for background layers and once for
    foreground layers.%
  }%
  \entry{\OptionVName{ontwoside}{code}}{%
    The \PName{code} of this hook\Index{hook} is executed whenever the output
    of the page style's layers in two-sided printing is initialised. Note that
    this happens twice for each page: once for background layers and once for
    foreground layers.%
  }%
  \entry{\OptionVName{onoddpage}{code}}{%
    The \PName{code} of this hook\Index{hook} is executed whenever the output
    of the page style's layers on an odd page is initialised. Note that this
    happens twice for each page: once for background layers and once for
    foreground layers. Note also that in one-sided printing all pages are odd
    pages, not just those with odd page numbers.%
  }%
  \entry{\OptionVName{onevenpage}{code}}{%
    The \PName{code} of this hook\Index{hook} is executed whenever the output
    of the page style's layers on an even page is initialised. Note that this
    happens twice for each page: once for background layers and once for
    foreground layers. Note also that in one-sided printing there are no even
    pages. Instead, all pages are treated as odd pages, not just those with
    odd page numbers.%
  }%
  \entry{\OptionVName{onfloatpage}{code}}{%
    The \PName{code} of this hook\Index{hook} is executed whenever the output
    of the page style's layers on a float page is initialised. Note that this
    happens twice for each page: once for background layers and once for
    foreground layers. Note also that float pages are only those pages with
    one or more p-placed floating environments.%
  }%
  \entry{\OptionVName{onnonfloatpage}{code}}{%
    The \PName{code} of this hook\Index{hook} is executed whenever the output
    of the page style's layers on a non-float page is initialised. Note that
    this happens twice for each page: once for background layers and once for
    foreground layers. Note also that float pages are only the pages on which
    one or more p-placed floating environments are output. Other pages may
    well have t-, h-, or b-placed floating environments.%
  }%
  \entry{\OptionVName{onbackground}{code}}{%
    The \PName{code} of this hook\Index{hook} is executed whenever the output
    of the page style's background layers is initialised. Note that this
    happens once each page.%
  }%
  \entry{\OptionVName{onforeground}{code}}{%
    The \PName{code} of this hook\Index{hook} is executed whenever the output
    of the page style's foreground layers is initialised. Note that this
    happens once each page.%
  }%
\end{desclist}

\iffalse% Umbruchvarianten
  While the \Macro{DeclarePageStyleByLayers} command always defines the page
  style, \Macro{DeclareNewPageStyleByLayers} generates an error message if a
  page style with the same name already exists. Note\textnote{Attention!} that
  the declaration of a page style that is already an alias for another page
  style (see, for example, \Macro{DeclareAliasPageStyle} earlier in this
  section) will redefine not the specified page style alias but the real page
  style (see \DescRef{\LabelBase.cmd.GetRealPageStyle} earlier in this
  section).%
\else%
  The \Macro{DeclarePageStyleByLayers} command defines the page style
  regardless of whether a page style of \PName{page style name} already
  exists. If necessary, the existing page style is completely
  redefined. However, if a page style alias \PName{page style name} already
  exists, the associated real page style, not the page style alias itself, is
  redefined (see \DescRef{\LabelBase.cmd.GetRealPageStyle} earlier in this
  section).

  The \Macro{DeclareNewPageStyleByLayers} command differs if a page style of
  the same name already exists. Regardless of whether it is a real or an alias
  page style, an error will be reported in this case.
\fi

In contrast, \Macro{ProvidePageStyleByLayers} preserves the page style
unchanged if a page style with name \PName{page style name} already exists. If
no such page style exists, it is defined as in
\Macro{DeclarePageStyleByLayers}.

The \Macro{RedeclarePageStyleByLayers} in turn expects that a page style of
of the name \PName{page style name} already exists and then redefines its real
page style. However, if no page style of the specified name exists, an error
message results.

Also note the remarks below about the pseudo-page style
\PageStyle{@everystyle@}.%
\EndIndexGroup


\begin{Declaration}
  \PageStyle{@everystyle@}%
  \PageStyle{empty}
\end{Declaration}
\BeginIndex{}{page style>layers}%
\BeginIndex{}{layers>page style}%
The \Package{scrlayer} package defines two specific page styles worth noting.
The first of these is \PageStyle{@everystyle@}%
\important{\PageStyle{@everystyle@}}. This page style should never be used
like a normal page style, for example with \DescRef{maincls.cmd.pagestyle} or
\DescRef{maincls.cmd.thispagestyle}, or as the target of a page-style alias.
Instead, the layers and hooks\Index{hooks} of this page style are used by all
other layer page styles. The hooks of \PageStyle{@everystyle@} are placed in
front of their respective hooks, and the layers in front of the respective
layers, of the active page style.

Thus adding a layer to the pseudo-page style \PageStyle{@everystyle@} or code
to a hook of this page style is like adding a layer or hook code to all layer
page styles, even the empty one. There's one crucial difference: commands that
reference the layers of a page style which include
\DescRef{\LabelBase.cmd.ForEachLayerOfPageStyle}, e.\,g., the commands
\DescRef{\LabelBase.cmd.AddLayersToPageStyleBeforeLayer} or
\DescRef{\LabelBase.cmd.AddLayersToPageStyleAfterLayer}, disregard the layers
of the page style \PageStyle{@everystyle@} when applied to a different layer
page style.

The second, slightly different page style is \PageStyle{empty}. Normally the
\LaTeX{} kernel defines the \PageStyle{empty} page style to have an empty
header and footer. The \Package{scrlayer} package redefines this page style as
a layerless page style. Nonetheless, you can use it like any other layer page
style. The main advantage of the layer page style over the original page
style from the \LaTeX{} kernel is that it also executes the hooks and layers
of the psuedo-layer page style \PageStyle{@everystyle@}.%
\EndIndexGroup


\begin{Declaration}
  \OptionVName{onpsselect}{code}%
  \OptionVName{onpsinit}{code}%
  \OptionVName{onpsoneside}{code}%
  \OptionVName{onpstwoside}{code}%
  \OptionVName{onpsoddpage}{code}%
  \OptionVName{onpsevenpage}{code}%
  \OptionVName{onpsfloatpage}{code}%
  \OptionVName{onpsnonfloatpage}{code}%
  \OptionVName{onpsbackground}{code}%
  \OptionVName{onpsforeground}{code}
\end{Declaration}
\BeginIndex{}{page style>layers}%
\BeginIndex{}{layers>page style}%
There is also a \KOMAScript{} option for each of the hooks\Index{hooks} in
\autoref{tab:scrlayer.pagestyle.hooks}%
\iftrue
. The names of the \KOMAScript{} options are similar to those for declaring
page style layers, except that a ``\texttt{ps}'' is inserted after
``\texttt{on}'' at the beginning of the name
\else
, into the names of which a ``\texttt{ps}'' is inserted
\fi
. The values of these \KOMAScript{} options are used as the initial values for
the corresponding hooks. These initial values are then extended by all the
values assigned to the corresponding hooks in the \PName{option list} of the
declaration commands. You can remove the default with
\DescRef{\LabelBase.cmd.ModifyLayerPageStyleOptions}, which is explained later
in this section.%
\EndIndexGroup


\begin{Declaration}
  \OptionVName{singlespacing}{simple switch}
\end{Declaration}
If\ChangedAt{v3.24}{\Package{scrlayer}\and \Package{scrlayer-scrpage}} a
document is printed with increased line spacing, e.\,g., using the
\Package{setspace}\IndexPackage{setspace}\important{\Package{setspace}}
package, it is often undesirable for the header and footer to be printed with
this increased spacing. This is particularly true if the header and footer
consist of only a single line. In this case you can use \KOMAScript{} option
\Option{singlespacing}. However, the default\textnote{default} is
\OptionValue{singlespacing}{false}! The option generally applies to all layer
page styles. If you want single-spacing for only some page styles, use
\OptionValue{oninit}{\Macro{linespread}\PParameter{1}\Macro{selectfont}} for
those page styles.%
\EndIndexGroup


\begin{Declaration}
  \OptionVName{deactivatepagestylelayers}{simple switch}%
  \Macro{ForEachLayerOfPageStyle}\Parameter{page style name}\Parameter{code}%
  \Macro{ForEachLayerOfPageStyle*}\Parameter{page style name}\Parameter{code}
\end{Declaration}
\BeginIndex{}{page style>layers}%
\BeginIndex{}{layers>page style}%
As long as the \KOMAScript{} option \Option{deactivatepagestylelayers} is not
enabled, the \Macro{ForEachLayerOfPageStyle} command can execute arbitrary
\PName{code} for each layer of the page style named \PName{page style name}.
Inside of \PName{code}, the place holder \PValue{\#1} serves as a
reference to the name of the current layer.
\begin{Example}
  If you want to print the names of all layers of the \PValue{scrheadings}
  page style as a comma-separated list, you can use:
\begin{lstcode}
  \let\commaatlist\empty
  \ForEachLayerOfPageStyle{scrheadings}{%
    \commaatlist#1\gdef\commaatlist{, }}
\end{lstcode}
\end{Example}
In\textnote{Attention!} the example above, we had to use \Macro{gdef} instead
of \Macro{def} because \Macro{ForEachLayerOfPageStyle} executes the 
\PName{code} inside a group to minimise side effects. However, \Macro{gdef}
redefines \Macro{commaatlist} globally so the change will persist when the
\PName{code} for the next layer is executed.

Alternatively,\ChangedAt{v3.18}{\Package{scrlayer}} you can use \Macro{def}
with the starred variant \Macro{ForEachLayerOfPageStyle*}. This form dispenses
with the extra group when executing \PName{code}. However, the user then has
to take make sure that the \PName{code} has no unwanted side effects. In
particular, deactivating all layers using
\OptionValue{deactivatepagestylelayers}{true} within \PName{code} would
persist beyond the call to \Macro{ForEachLayerOfPageStyle*}.

Various \Package{scrlayer} commands also use \Macro{ForEachLayerOfPageStyle}
internally. Their behaviour can therefore also be changed using the
\KOMAScript{} option \Option{deactivatepagestylelayers}. With this option,
you can temporarily disable and thus hide all layers of all layer page
styles.%
\EndIndexGroup


\begin{Declaration}
  \Macro{AddLayersToPageStyle}%
  \Parameter{page style name}\Parameter{layer list}%
  \Macro{AddLayersAtBeginOfPageStyle}%
  \Parameter{page style name}\Parameter{layer list}%
  \Macro{AddLayersAtEndOfPageStyle}%
  \Parameter{page style name}\Parameter{layer list}%
  \Macro{RemoveLayersFromPageStyle}%
  \Parameter{page style name}\Parameter{layer list}%
\end{Declaration}
\BeginIndex{}{page style>layers}%
\BeginIndex{}{layers>page style}%
You can use these commands to add layers to a layer page style or to remove
layers from a layer page style. The page style is referenced by its
\PName{page style name}. The layers are given by a comma-separated
\PName{layer list}.

Both the \Macro{AddLayersToPageStyle} and the
\Macro{AddLayersAtEndOfPageStyle}\textnote{add at the end} commands insert the
new layers at the bottom of the page style's layer list. Logically, the newly
added layers lie above or in front of the old layers. Background layers, of
course, still are logically behind the text layer and thus behind all
foreground layers.

In contrast, the \Macro{AddLayersAtBeginOfPageStyle}\textnote{add at the
  beginning} command inserts the new layers at the top of the page style's
layer list. The layers are separately inserted to the top of the list in the
same order they appear in the \PName{layer list} parameter. This means that
the last layer in the \PName{layer list} parameter will become the first, and
thus the lowest, layer of the page style.

\iffalse% Umbruchkorrekturtext (beim Aktiveren muss unten \textnote{remove}
% entfernt werden!)
The \Macro{RemoveLayersFromPageStyle} command is exactly the opposite. It
removes\textnote{remove} the specified page-style levels.%
\fi

The \Macro{RemoveLayersFromPageStyle}\textnote{remove} command removes layers
from the layer list of the page style named \PName{page style name}.
Attempting to remove layers which are not part of the page style's layer list
will be ignored. But attempting to add layers to or remove layers from a page
style that is neither a layer page style nor a page-style alias is an error
and will be reported as such.%
\EndIndexGroup


\begin{Declaration}
  \Macro{AddLayersToPageStyleBeforeLayer}%
  \Parameter{page style name}\Parameter{layer list}%
  \Parameter{reference layer name}%
  \Macro{AddLayersToPageStyleAfterLayer}%
  \Parameter{page style name}\Parameter{layer list}%
  \Parameter{reference layer name}
\end{Declaration}
\BeginIndex{}{page style>layers}%
\BeginIndex{}{layers>page style}%
\iffalse% Umbruchvarianten
These two commands are similar to the previous ones, but they take an
additional parameter,  \Parameter{reference layer name}. The layer list of
the page style named in \Parameter{page style name} is searched for this
reference layer. %
\else%
These commands are similar to the previous ones. The existing layers of the
page style, however, are searched for the \PName{reference layer name}. %
\fi%
The layers in the \Parameter{layer list} parameter are then inserted
before\textnote{add before/after layer} or after this reference layer%
\iffalse% Umbruchkorrekturtext
in the layers of the page style%
\fi%
. The order of the layers in the \PName{layer list} is retained.

If the reference layer named \PName{reference layer name} is not part of the
given page style, nothing is inserted. On the other hand, if the page style is
neither a layer page style nor a page-style alias, an error will be reported.%
\EndIndexGroup


\begin{Declaration}
  \Macro{UnifyLayersAtPageStyle}\Parameter{page style name}
\end{Declaration}
\BeginIndex{}{page style>layers}%
\BeginIndex{}{layers>page style}%
The commands for defining page styles or adding layers to a page style do not
care how many times a layer appears in a page style, so it is quite
permissible for a layer to appear multiple times. In most cases, however, it
does not make sense to use the same layer several times in one page style.
Therefore, you can use \Macro{UnifyLayersAtPageStyle} to remove all layer
duplicates from the layer page style of the specified \Parameter{page style
	name}.

Note\textnote{Attention!} that this function can change the order of layers.
So if you need a specific order, you should remove all layers and add the
layers in the order you want instead of using \Macro{UnifyLayersAtPageStyle}.%
\EndIndexGroup


\begin{Declaration}
  \Macro{ModifyLayerPageStyleOptions}%
  \Parameter{page style name}\Parameter{option list}%
  \Macro{AddToLayerPageStyleOptions}%
  \Parameter{page style name}\Parameter{option list}
\end{Declaration}
\BeginIndex{}{page style>layers}%
\BeginIndex{}{layers>page style}%
These two commands can be used to modify the options, and thus the
hooks\Index{hooks}, of a layer page style. With
\Macro{ModifyLayerPageStyleOptions}\textnote{change page-style options}, only
the options in the comma-separated \PName{option list} will be set to the new
values given there. The previous values are lost. All options from
\autoref{tab:scrlayer.pagestyle.hooks},
\autopageref{tab:scrlayer.pagestyle.hooks} are allowed. Options or hooks that
are not specified in the \PName{option list} will remain unchanged. If you
want to set an option to do nothing you can set it to the value \Macro{relax}.
Setting an option to a new value using \Macro{ModifyLayerPageStyleOptions}
will remove the previous value, including the global default value. This
statement is the only way to remove the global defaults of the \KOMAScript{}
options from a page style.

\Macro{AddToLayerPageStyleOptions}\textnote{extend page-style options}, on the
other hand, does not overwrite the previous values. Instead it adds\,---\,or,
more precisely, concatenates\,---\, the new values to old ones.%
\EndIndexGroup


\begin{Declaration}
  \Macro{IfLayerPageStyleExists}%
  \Parameter{page style name}\Parameter{then code}\Parameter{else code}%
  \Macro{IfRealLayerPageStyleExists}%^
  \Parameter{page style name}\Parameter{then code}\Parameter{else code}%
\end{Declaration}
\BeginIndex{}{page style>layers}%
\BeginIndex{}{layers>page style}%
With these commands, you can execute code depending on whether a page style is
a layer page style or not. The \Macro{IfLayerPageStyleExists} command executes
the \PName{then code} if \PName{page style name} is the name of a layer page
style or a page-style alias that results in a layer page style. Otherwise, the
command executes the \PName{else code}. Internally, this command is often used
to throw an error message if you use one of the layer page style commands with
an \PName{page style name} that does not correspond to a layer page style.

The \Macro{IfRealLayerPageStyleExists} command goes one step further and
executes the \PName{then code} only if the page style specified by \PName{page
  style name} is itself a layer page style. So if \PName{page style name} is a
page-style alias, this command executes the \PName{else code} even if the
alias resolves to a real layer page style.%
\EndIndexGroup


\begin{Declaration}
  \Macro{IfLayerAtPageStyle}%
  \Parameter{page style name}\Parameter{layer name}%
  \Parameter{then code}\Parameter{else code}%
  \Macro{IfSomeLayerAtPageStyle}%
  \Parameter{page style name}\Parameter{layer list}%^
  \Parameter{then code}\Parameter{else code}%
  \Macro{IfLayersAtPageStyle}%
  \Parameter{page style name}\Parameter{layer list}%
  \Parameter{then code}\Parameter{else code}%
\end{Declaration}
\BeginIndex{}{page style>layers}%
\BeginIndex{}{layers>page style}%
These commands can be used to test whether one or more layers are part of a
page style. The \Macro{IfLayerAtPageStyle} command expects exactly one
\PName{layer name}\textnote{exactly one layer} as the second argument. If this
layer is part of the page style specified in \PName{page style name}, the
\PName{then code} will be executed. Otherwise, the \PName{else code} will be
executed.

The \Macro{IfSomeLayerAtPageStyle} and \Macro{IfLayersAtPageStyle} commands
allow a comma-separated \PName{layer list}. \Macro{IfSomeLayerAtPageStyle}
will execute the \PName{then code} if \emph{at least one} of the layers in the
\PName{layer list} parameter is part of the layer list of \PName{page style
  name}. In contrast, \Macro{IfLayersAtPageStyle} executes the \PName{then
  code} only if \emph{all} the layers in the \PName{layer list} parameter are
part of the page style. If the condition is not met, the \PName{else code}
will be executed.

With suitable nesting of these commands, you can construct complex conditions.
If you use only one \PName{layer name} in the \PName{layer list}, all three
statements are synonymous.%
\EndIndexGroup


\begin{Declaration}
  \Macro{DestroyRealLayerPageStyle}\Parameter{page style name}
\end{Declaration}
\BeginIndex{}{page style>layers}%
\BeginIndex{}{layers>page style}%
\iftrue
This statement makes a layer page style undefined. If a page-style alias or
ordinary page style is specified, the command is ignored.
\else
With this command you can remove a the definition of a layer page style.
However, this only occurs if a layer page style named \PName{page style name}
exists. If, instead, it is a page-style alias, a different (non-layer) page
style, or not a page style at all, nothing happens; the command is ignored.%
\fi

If \PName{page style name} is the name of the current page style, the current
page style will becomes a kind of empty page style. If the page style set with
\DescRef{maincls.cmd.thispagestyle} is \PName{page style name}, it will simply
be reset. The previous \DescRef{maincls.cmd.thispagestyle} command loses its
current effect.

Note\textnote{Attention!} that the layers of the page style are not destroyed
automatically. If you want to destroy the layers too, you can do this with: 
\begin{lstcode}
  \ForEachLayerOfPageStyle{...}{\DestroyLayer{#1}}
\end{lstcode}
before destroying the layer page style itself.%
\iffalse % See the note at the beginning of the end user interface section
\par
The command is intended to be used within the \PName{code} argument of
\DescRef{\LabelBase.cmd.scrlayerOnAutoRemoveInterface} to remove page styles
that are defined as part of an end-user interface. See
\autoref{sec:scrlayer.enduserinterfaces} below for more information about
auto-removal code.%
\fi%
\EndIndexGroup
\EndIndexGroup

\LoadCommonFile{headfootheight}% \section{Height of Page Head and Foot}

\LoadCommonFile{pagestylemanipulation}% \section{Manipulation of Defined Page Styles}

\section{Defining and Managing Interfaces for End Users}
\seclabel{enduserinterfaces}

\iftrue% The whole mechanism is deprecated and should not be used any
       % longer. So the documentation is also deactivated.
% TODO: Fix new translation
Until version 3.27\ChangedAt{v3.28}{\Package{scrlayer}} package
\Package{scrlayer} provided mechanism to manage concurrent end user
interfaces. The mechanism has been marked as experimental and the usability
limited. Only \KOMAScript{} itself has used this mechanism and from version
3.28 it is marked as deprecated. So the commands
\Macro{scrlayerInitInterface}\IndexCmd{scrlayerInitInterface},
\Macro{scrlayerAddToInterface}\IndexCmd{scrlayerAddToInterface},
\Macro{scrlayerAddCsToInterface}\IndexCmd{scrlayerAddCsToInterface},
\Macro{scrlayerOnAutoRemoveInterface}\IndexCmd{scrlayerOnAutoRemoveInterface}%
\important{\Macro{scrlayerOnAutoRemoveInterface}}
and the options
\Option{forceoverwrite}\IndexOption{forceoverwrite},
\Option{autoremoveinterfaces}\IndexOption{autoremoveinterfaces}
should not be used any longer.%
% :ODOT
\else%
The \Package{scrlayer} package provides an experimental interface to define
and manage (concurrent) interfaces for end users. \iffree{In the long run,
  this interface may disappear from \Package{scrlayer} and be taken over by
  \Package{scrbase} instead.}{} Currently, this interface is highly
experimental%
\iffree{ and therefore \Package{scrlayer} provides these interface commands
  only for the use of subpackages of \Package{scrlayer}}{}%
. Given the current state of development, you should not depend on automatic
removal of a concurrent interface to work. Instead, you should avoid using
concurrent end-user interfaces.

This section only describes the interface commands for defining an end-user
interface. For end users themselves, it is of little interest. Rather, this
section is intended for authors of packages and classes that build on
\Package{scrlayer}. End users will find information about specific end-user
interfaces in \autoref{cha:scrlayer-scrpage},
\autoref{cha:scrlayer-scrpage-experts}, and \autoref{cha:scrlayer-notecolumn}.

\begin{Declaration}
  \Macro{scrlayerInitInterface}\OParameter{interface name}
\end{Declaration}
The \Macro{scrlayerInitInterface} command registers a new interface named
\PName{interface name}. The \PName{interface name} must be unique. If an
interface with the same name has already been registered, an error will occur.

This command should always appear as the first command when defining an
end-user interface and therefore is described here first. If the optional
argument\,---\,including the square brackets\,---\,is omitted,
\PValue{\Macro{@currname}.\Macro{@currext}} will be used instead. For classes
and packages, this is the file name of the class or package. But of course you
can use any other sequence of characters with a category of \emph{letter} or
\emph{other}. This is useful, for example, when a class or package defines
multiple end-user interfaces%
\EndIndexGroup


\begin{Declaration}
  \OptionVName{forceoverwrite}{simple switch}%
  \OptionVName{autoremoveinterfaces}{simple switch}%
  \Macro{scrlayerAddToInterface}%
  \OParameter{interface name}\Parameter{command}\Parameter{code}%
  \Macro{scrlayerAddCsToInterface}%
  \OParameter{interface name}\Parameter{command sequence}\Parameter{code}
\end{Declaration}
One of the special features of \Package{scrlayer}'s end user interfaces is
that they should register all interface-dependent commands (also known as
\emph{macros}). You can do this using \Macro{scrlayerAddToInterface}. The
optional argument \PName{interface name} must be an interface name previously
registered with \DescRef{\LabelBase.cmd.scrlayerInitInterface}. An error will
occur if the interface has not been initialised.

If\textnote{Attention!} your interface defines macros not just when the class
or package is being loaded but also at runtime, you must provide the interface
name in the optional argument even if it corresponds to the file name of the
class or package, since the values of \Macro{@currname} and \Macro{@currext}
are only valid while the class or package is being loaded.

The first mandatory argument is the \PName{command}\footnote{The
  \PName{command} consists of a backslash followed by a \PName{command
    sequence} that consists of characters of the category code \emph{letter},
  or of exactly one character of the category \emph{other}, or of a character
  of the category \emph{active} (without the backslash).} to be added to the
interface. If the command can be defined, this will be done. In addition, it
will set to \Macro{relax} and \PName{code} will be executed. Within
\PName{code}, you can then define \PName{command}, e.\,g., using
\Macro{newcommand}.

But when can a command be defined? If a command is undefined or \Macro{relax},
it can always be defined. If a command has already been defined \emph{and}
registered for another interface \emph{and} if the \KOMAScript{} option
\Option{autoremoveinterfaces} has been activated, the other interface will be
removed automatically, and the \PName{command} will be set to \Macro{relax}
and registered for the new interface specified. If a \PName{command} is
already defined but is \emph{not} part of another interface, \emph{and} if the
\KOMAScript{} option \Option{forceoverwrite} has been activated, the
\PName{command} is also set to \Macro{relax} and registered for the specified
interface. In all other cases, however, the command is not definable, in
particular if it is already defined and the \KOMAScript{} options
\Option{autoremoveinterfaces} and \Option{forceoverwrite} are deactivated.

The \Macro{scrlayerAddCsToInterface} command is similar to
\Macro{scrlayerAddToInterface} but it expects the first argument to be not a
\PName{command} but a command sequence\footnote{A command sequence must be
  fully expandable and its expansion must result in characters of the category
  code \emph{letter}, \emph{other}, or \emph{space}.}.%
\EndIndexGroup


\begin{Declaration}
  \Macro{scrlayerOnAutoRemoveInterface}%
  \OParameter{interface name}\Parameter{code}
\end{Declaration}
The \Macro{scrlayerOnAutoRemoveInterface} command registers \PName{code} to be
executed in the event that the end-user interface with the specified
\PName{interface name} is automatically removed (see
\DescRef{\LabelBase.option.autoremoveinterfaces} earlier in this section).
This can be used, for example, to automatically destroy layers or page styles
that rely on commands from the end-user interface (see
\DescRef{\LabelBase.cmd.DestroyLayer},
\DescRef{\LabelBase.cmd.DestroyPageStyleAlias}, and
\DescRef{\LabelBase.cmd.DestroyRealLayerPageStyle}). Regarding the default for
the optional argument, please refer to the explanation for
\DescRef{\LabelBase.cmd.scrlayerInitInterface}.%
\EndIndexGroup%
\fi%
%
\EndIndexGroup

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "scrguide-en.tex"
%%% coding: utf-8
%%% ispell-local-dictionary: "en_GB"
%%% eval: (flyspell-mode 1)
%%% End:
